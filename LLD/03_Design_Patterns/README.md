# Design Patterns

 

Design patterns are like **ready-made solutions** for common problems developers face. They are not finished code, but **templates/blueprints** to make your software more structured, manageable, and scalable.  

---

## Why Learn Design Patterns?

- Write code that’s **easier to understand, maintain, and expand**.  
- Use **tried-and-tested best practices** instead of reinventing the wheel.  
- Build **reusable components** for multiple projects, saving time and effort.  
- Communicate effectively with other developers using **standard terminology**.  

---

## Key Characteristics

- **Reusability** - Apply patterns across projects easily. 
- **Standardization** - Shared language among developers. 
- **Efficiency** - Avoid solving the same problems repeatedly. 
- **Flexibility** - Adapt templates to fit different scenarios. 

---

## Types of Design Patterns

Design patterns are broadly classified into **3 types**:

### 1. Creational Patterns 
Focus: **Object creation** – how objects are instantiated.  

**Popular Patterns:**
- **Factory Method:** Create objects without specifying exact class.  
- **Abstract Factory:** Factory of factories for layered abstraction.  
- **Singleton:** Ensure only one instance exists globally.  
- **Prototype:** Copy existing objects instead of creating new ones.  
- **Builder:** Construct complex objects **step by step**.  

---

### 2. Structural Patterns 
Focus: **Composition** – how classes and objects form larger structures.  

**Popular Patterns:**
- **Adapter:** Make incompatible interfaces work together.  
- **Bridge:** Decouple abstraction from implementation.  
- **Composite:** Treat individual objects and collections uniformly.  
- **Decorator:** Add behavior dynamically without changing others.  
- **Facade:** Simplify complex subsystem interfaces.  
- **Flyweight:** Reduce object count for efficiency.  
- **Proxy:** Control access to another object.  

---

### 3. Behavioral Patterns 
Focus: **Communication & responsibility** – how objects interact.  

**Popular Patterns:**
- **Chain of Responsibility:** Pass requests along a chain of objects.  
- **Command:** Encapsulate requests as objects for flexibility.  
- **Interpreter:** Define grammar and interpret expressions.  
- **Mediator:** Centralize communication between objects.  
- **Memento:** Save and restore object state.  
- **Observer:** One-to-many dependency updates automatically.  
- **State:** Change behavior based on internal state.  
- **Strategy:** Choose behavior at runtime dynamically.  
- **Template Method:** Define algorithm skeleton; let subclasses fill in details.  
- **Visitor:** Move operational logic out of objects for better separation.  

---

